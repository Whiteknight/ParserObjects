using System.Text;

namespace ParserObjects.CodeGen
{
    internal class RulesGenerator
    {
        public string GetRulesDefs()
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;").AppendLine();
            sb.AppendLine("namespace ParserObjects;").AppendLine();
            sb.AppendLine("public static partial class Parsers<TInput>");
            sb.AppendLine("{");
            for (int num = 2; num <= 9; num++)
            {
                GenerateRuleMethod(num, sb);
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private void GenerateRuleMethod(int num, StringBuilder sb)
        {
            if (num > 2)
                sb.AppendLine();
            sb.Append("    public static partial IParser<TInput, TOutput> Rule<").TArgsList(num).AppendLine(", TOutput>(");
            for (int i = 1; i <= num; i++)
                sb.AppendLine($"        IParser<TInput, T{i}> p{i},");
            sb.Append("        Func<").TArgsList(num).AppendLine(", TOutput> produce)");
            sb.AppendLine("    {");
            sb.AppendLine("        return Internal.Parsers.Function<TInput, TOutput>.Create(");

            // First, the value tuple with parsers and produce method
            sb.Append("            (").PList(num).AppendLine(", produce),");

            // Second, the static parse method
            sb.AppendLine("            static (state, args, resultFactory) =>");
            sb.AppendLine("            {");
            sb.Append("                var (").PList(num).AppendLine(", produce) = args;");
            for (int i = 1; i <= num; i++)
            {
                sb.AppendLine($"                var r{i} = p{i}.Parse(state);");
                sb.AppendLine($"                if (!r{i}.Success)");
                sb.AppendLine($"                    return resultFactory.Failure(r{i}.ErrorMessage);");
            }

            sb.Append("                var result = produce(").RValueList(num).AppendLine(");");
            sb.AppendLine("                return resultFactory.Success(result);");
            sb.AppendLine("            },");

            // Third the static match method
            sb.AppendLine("            static (state, args) =>");
            sb.AppendLine("            {");
            sb.Append("                var (").PList(num).AppendLine(", produce) = args;");
            sb.AppendLine("                var cp = state.Input.Checkpoint();");

            sb.Append("                var ok = p1.Match(state)");
            for (int i = 2; i <= num; i++)
                sb.Append($" && p{num}.Match(state)");
            sb.AppendLine(";");

            sb.AppendLine("                if (!ok)");
            sb.AppendLine("                    cp.Rewind();");
            sb.AppendLine("                return ok;");
            sb.AppendLine("            },");

            // Fourth, the Description/format
            sb.Append("            \"({child}");
            for (int i = 2; i <= num; i++)
                sb.Append(" {child}");
            sb.AppendLine(")\",");

            // Fifth, list of child parsers
            sb.Append("            new IParser[] { ").PList(num).AppendLine(" });");
            sb.AppendLine("    }");
        }
    }
}
