<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ParserObjects</name>
    </assembly>
    <members>
        <member name="M:ParserObjects.CPlusPlusStyleParserMethods.Comment">
            <summary>
            C++-style comment '//' ...
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.Comment">
            <summary>
            C-style comment with '/*' ... '*/' delimiters
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.HexadecimalString">
            <summary>
            C-style hexadecimal literal returned as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.HexadecimalInteger">
            <summary>
            C-style hexadecimal literal returned as a parsed integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.IntegerString">
            <summary>
            C-style integer literal returned as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.Integer">
            <summary>
            C-style Integer literal returned as a parsed Int32
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.UnsignedIntegerString">
            <summary>
            C-style unsigned integer literal returned as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.UnsignedInteger">
            <summary>
            C-style Unsigned Integer literal returned as a parsed Int32
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.DoubleString">
            <summary>
            C-style Double literal returned as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.Double">
            <summary>
            C-style float/double literal returned as a parsed Double
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.Identifier">
            <summary>
            C-style Identifier
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.StrippedString">
            <summary>
            Parse a C-style string, removing quotes and replacing escape sequences with their
            proper values
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.String">
            <summary>
            Parse a C-style string, keeping quotes and escape sequences.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.StrippedCharacter">
            <summary>
            Parses a C-style char literal, removing quotes and resolving escape sequences.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.CStyleParserMethods.Character">
            <summary>
            Parse a C-style char literal, keeping the quotes and escape sequences
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IDataStore">
            <summary>
            Storage for contextual/state data during a parse
            </summary>
        </member>
        <member name="M:ParserObjects.IDataStore.Get``1(System.String)">
            <summary>
            Get the data value with the given name, cast to type T. If the data does not exist
            or is not assignable to T, the call fails
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.IDataStore.Set``1(System.String,``0)">
            <summary>
            Set a data value with type T to the given name in the current data frame
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="T:ParserObjects.IParser">
            <summary>
            Parser base type.
            </summary>
        </member>
        <member name="P:ParserObjects.IParser.Name">
            <summary>
            The name of the parser. This value is only used for bookkeeping information and does not have
            an affect on the parse.
            </summary>
        </member>
        <member name="M:ParserObjects.IParser.GetChildren">
            <summary>
            Get a list of child parsers, if any.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IParser`1">
            <summary>
            Parser object which allows getting the result without type information
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="M:ParserObjects.IParser`1.Parse(ParserObjects.ParseState{`0})">
            <summary>
            Attempt to parse the input sequence and produce an output result of type object. If the parse
            fails, it is expected that this method will return the input sequence to the state it was at
            before the parse was attempted.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IParser`2">
            <summary>
            Parser with explicit input and output types.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="M:ParserObjects.IParser`2.Parse(ParserObjects.ParseState{`0})">
            <summary>
            Attempt to parse the input sequence and produce an output result. If the parse fails, it is
            expected that this method will return the input sequence to the state it was at before the
            parse was attempted.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IReplaceableParserUntyped">
            <summary>
            A parser which has an in-place replaceable child. Used to identify parsers which can participate in
            certain find/replace operations
            </summary>
        </member>
        <member name="P:ParserObjects.IReplaceableParserUntyped.ReplaceableChild">
            <summary>
            The child parser which can be replaced without cloning
            </summary>
        </member>
        <member name="M:ParserObjects.IReplaceableParserUntyped.SetParser(ParserObjects.IParser)">
            <summary>
            Set the new child parser without cloning
            </summary>
            <param name="parser"></param>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.FindNamed(ParserObjects.IParser,System.String)">
            <summary>
            Recurse the tree searching for a parser with the given name. Returns the first matching result.
            </summary>
            <param name="root"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.Replace(ParserObjects.IParser,System.Func{ParserObjects.IParser,System.Boolean},ParserObjects.IParser)">
            <summary>
            Given a parser tree, replace all children of ReplaceableParsers matching the given predicate with
            the provided replacement parser.
            </summary>
            <param name="root"></param>
            <param name="predicate"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.Replace(ParserObjects.IParser,ParserObjects.IParser,ParserObjects.IParser)">
            <summary>
            Given a parser tree, find a ReplaceableParser with a child which is reference equal to the given
            find parser, and replaces it with the given replacement parser.
            </summary>
            <param name="root"></param>
            <param name="find"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.Replace``2(ParserObjects.IParser,System.Func{ParserObjects.IParser,System.Boolean},System.Func{ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0,``1}})">
            <summary>
            Given a parser tree, find a ReplaceableParsers matching a predicate and attempt to transform
            the contents using the given transformation. The contents of the ReplaceableParser will be
            replaced with the transformed result if it is new and valid.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="root"></param>
            <param name="predicate"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.Replace(ParserObjects.IParser,System.String,ParserObjects.IParser)">
            <summary>
            Given a parser tree, find a ReplaceableParser with the given name and replace it's child parser
            with the given replacement parser
            </summary>
            <param name="root"></param>
            <param name="name"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserFindReplaceExtensions.Replace``2(ParserObjects.IParser,System.String,System.Func{ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0,``1}})">
            <summary>
            Given a parser tree, find a ReplaceableParser matching a predicate and attempt to transform
            the contents using the given transformation. The contents of the ReplaceableParser will be
            replaced with the transformed result if it is new and valid.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="root"></param>
            <param name="name"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserLogicalExtensions.And``1(ParserObjects.IParser{``0},ParserObjects.IParser{``0}[])">
            <summary>
            Parse the given parser and all additional parsers sequentially. Consumes input but returns no
            output. Will probably be used by Positive- or Negative-lookahead or If.
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="p1"></param>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserLogicalExtensions.If``2(ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0})">
            <summary>
            Attempt to parse with a predicate parser, consuming no input. If the predicate parser succeeds,
            parse with the given parser.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserLogicalExtensions.Not``1(ParserObjects.IParser{``0})">
            <summary>
            Parses with the given parser, inverting the result so Success becomes Failure and Failure becomes
            Success. Consumes input but returns no output. Will probably be used by Positive- or
            Negative-lookahead or If.
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserLogicalExtensions.Or``1(ParserObjects.IParser{``0},ParserObjects.IParser{``0}[])">
            <summary>
            Attempts to parse with each parser successively, returning Success if any parser succeeds
            or Failure if none do. Consumes input but returns no output. Will probably be used by
            Positive- or Negative-lookahed or If
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="p1"></param>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserLogicalExtensions.Then``2(ParserObjects.IParser{``0},ParserObjects.IParser{``0,``1})">
            <summary>
            Attempt to parse with a predicate parser, consuming no input. If the predicate parser succeeds,
            parse with the given parser. This is the same operation as If with different order of operands.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="predicate"></param>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.ParserMatchParseExtensions">
            <summary>
            General-purpose extensions for IParser and descendents
            </summary>
        </member>
        <member name="M:ParserObjects.ParserMatchParseExtensions.CanMatch``1(ParserObjects.IParser{``0},ParserObjects.ISequence{``0})">
            <summary>
            Attempts a parse but does not consume any input. Instead it returns a boolean true if the parse
            succeeded or false otherwise.
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="parser"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMatchParseExtensions.CanMatch(ParserObjects.IParser{System.Char},System.String)">
            <summary>
            Convenience method for parsers which act on character sequences. Attempts a parse but does not
            consume any input. Returns true if the parse would succeed, false otherwise.
            </summary>
            <param name="parser"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMatchParseExtensions.Parse``1(ParserObjects.IParser{System.Char,``0},System.String,System.Action{System.String})">
            <summary>
            Convenience method for parser which act on character sequences. Parse the given input string
            and return the first value or failure. Creates a character sequence from the string
            and the ParseState object
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="s"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMatchParseExtensions.Parse``2(ParserObjects.IParser{``0,``1},ParserObjects.ISequence{``0},System.Action{System.String})">
            <summary>
            Convenience method to invoke a parser which acts on an input sequence. Creates the
            necessary ParseState.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="input"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMatchParseExtensions.Parse``1(ParserObjects.IParser{``0},ParserObjects.ISequence{``0},System.Action{System.String})">
            <summary>
            Covenience method to invoke a parser which does not return a value. Creates the
            necessary ParseState.
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="parser"></param>
            <param name="input"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserResultsExtensions.TransformError``2(ParserObjects.IParser{``0,``1},ParserObjects.Parsers.TransformResult{``0,``1,``1}.Function)">
            <summary>
            If the result is an error, invoke the callback to modify the result and result
            metadata. If the original result is success, return it without modification.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.ParserCombinatorExtensions">
            <summary>
            IParser extension methods for building combinators using fluent syntax
            </summary>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Chain``3(ParserObjects.IParser{``0,``1},System.Func{``1,ParserObjects.IParser{``0,``2}})">
            <summary>
            Execute a parser and use the result to select the next parser to invoke
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getNext"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Choose``3(ParserObjects.IParser{``0,``1},System.Func{``1,ParserObjects.IParser{``0,``2}})">
            <summary>
            Execute a parser but consume no input. Use the result to select the next parser to
            invoke
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getNext"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Examine``2(ParserObjects.IParser{``0,``1},System.Action{ParserObjects.Parsers.Examine{``0,``1}.Context},System.Action{ParserObjects.Parsers.Examine{``0,``1}.Context})">
            <summary>
            Invoke callbacks before and after a parse
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="before"></param>
            <param name="after"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Examine``1(ParserObjects.IParser{``0},System.Action{ParserObjects.Parsers.Examine{``0}.Context},System.Action{ParserObjects.Parsers.Examine{``0}.Context})">
            <summary>
            Invoke callbacks before and after a parse
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="parser"></param>
            <param name="before"></param>
            <param name="after"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.FollowedBy``2(ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0})">
            <summary>
            Zero-length assertion that the given parser's result is followed by another sequence.
            The lookahead sequence is matched but not consumed
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="lookahead"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.List``2(ParserObjects.IParser{``0,``1},System.Boolean)">
            <summary>
            Returns a list of results from the given parser. Continues to parse until the parser returns
            failure. Returns an enumerable of results.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="atLeastOne"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.List``2(ParserObjects.IParser{``0,``1},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns a list of results from the given parser, with limits. Continues to
            parse until the parser returns failure or the maximum number of results is
            reached.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="minimum"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.ListCharToString(ParserObjects.IParser{System.Char,System.Char},System.Boolean)">
            <summary>
            Given a parser which parses characters, parse a list of characters and return the sequence as a
            string
            </summary>
            <param name="p"></param>
            <param name="atLeastOne"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.ListCharToString(ParserObjects.IParser{System.Char,System.Char},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Given a parser which parsers characters, parse a list of characters and return
            the result as a string. Supports limits for minimum and maximum numbers of
            characters to parse.
            </summary>
            <param name="p"></param>
            <param name="minimum"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.ListSeparatedBy``3(ParserObjects.IParser{``0,``2},ParserObjects.IParser{``0,``1},System.Boolean)">
            <summary>
            Returns a list of results from the given parser separated by a separator pattern. Continues until
            the item or separator parser return failure. Returns an enumerable of results.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TSeparator"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="separator"></param>
            <param name="atLeastOne"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.ListSeparatedBy``3(ParserObjects.IParser{``0,``2},ParserObjects.IParser{``0,``1},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns a list of results from the given parser separated by a separator
            pattern. Continues until the item or separator pattern return failure, or
            the minimum/maximum counts are not satisfied. Returns an enumeration of results
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TSeparator"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="separator"></param>
            <param name="minimum"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.ListStringsToString(ParserObjects.IParser{System.Char,System.String},System.Boolean)">
            <summary>
            Given a parser which parses strings, parse a list of strings and return the sequence as a joined
            string
            </summary>
            <param name="p"></param>
            <param name="atLeastOne"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Map``3(ParserObjects.IParser{``0,``1},System.Func{``1,``2})">
            <summary>
            Transform the output of the given parser. Synonym for Transform
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.NotFollowedBy``2(ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0})">
            <summary>
            Zero-length assertion that the given parser's match result is not followed by a lookahead pattern.
            The lookahead is compared but no input is consumed to match it.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="lookahead"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Optional``2(ParserObjects.IParser{``0,``1},System.Func{``1})">
            <summary>
            The results of the given parser are optional. If the given parser fails, a default value will
            be provided 
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getDefault"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Optional``2(ParserObjects.IParser{``0,``1},System.Func{ParserObjects.ISequence{``0},``1})">
            <summary>
            The results of the given parser are optiona. If the given parser fails, a default value will be
            provided
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getDefault"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Replaceable``2(ParserObjects.IParser{``0,``1})">
            <summary>
            Make this parser replaceable
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Replaceable``2(ParserObjects.IParser{``0,``1},System.String)">
            <summary>
            Make this parser replaceable. Gives the parser a name so that it can be easily
            found and replaced
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserCombinatorExtensions.Transform``3(ParserObjects.IParser{``0,``1},System.Func{``1,``2})">
            <summary>
            Transform the output of the given parser to a new value 
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserExtensions.Named``1(``0,System.String)">
            <summary>
            Specify a name for the parser with function syntax.
            </summary>
            <typeparam name="TParser"></typeparam>
            <param name="parser"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserExtensions.ToBnf(ParserObjects.IParser)">
            <summary>
            Attempt to describe the parser as a string of pseudo-BNF. This feature depends on parsers having
            a .Name value set. If you are using custom IParser implementations you will need to use a custom
            BnfStringifyVisitor subclass to account for it.
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserExtensions.ToSequence``2(ParserObjects.IParser{``0,``1},ParserObjects.ISequence{``0},System.Action{System.String})">
            <summary>
            Convert a parser and it's input sequence into a new sequence of parse result values
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="input"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IReadOnlyTrie`2">
            <summary>
            A trie type which allows using a composite key to search for values. This trie cannot be
            modified once created
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:ParserObjects.IReadOnlyTrie`2.Get(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Given a composite key, search for a value at that location in the trie
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.IReadOnlyTrie`2.Get(ParserObjects.ISequence{`0})">
            <summary>
            Given a sequence, treat the items in that sequence as elements of a composite key. Return a
            value from the trie which successfully consumes the most amount of input items.
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.IReadOnlyTrie`2.GetAllPatterns">
            <summary>
            Get all the pattern sequences in the trie. This operation may iterate over the entire trie so
            the results should be cached if possible.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IInsertableTrie`2">
            <summary>
            A trie to which items can be added
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:ParserObjects.IInsertableTrie`2.Add(System.Collections.Generic.IEnumerable{`0},`1)">
            <summary>
            Given a composite key and a value, insert the value at the location described by the key
            </summary>
            <param name="keys"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.TrieExtensions.ToParser``2(ParserObjects.IReadOnlyTrie{``0,``1})">
            <summary>
            Wrap the Trie in a TrieParser
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="readOnlyTrie"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.TrieExtensions.Add(ParserObjects.IInsertableTrie{System.Char,System.String},System.String)">
            <summary>
            Convenience method to add a string value with char keys
            </summary>
            <param name="readOnlyTrie"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.TrieExtensions.AddMany(ParserObjects.IInsertableTrie{System.Char,System.String},System.String[])">
            <summary>
            Convenience method to add strings to the trie with char keys
            </summary>
            <param name="readOnlyTrie"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.IResult">
            <summary>
            Result object from a Parse operation
            </summary>
        </member>
        <member name="P:ParserObjects.IResult.Success">
            <summary>
            Returns true if the parse succeeded, false otherwise.
            </summary>
        </member>
        <member name="P:ParserObjects.IResult.Location">
            <summary>
            The approximate location of the successful parse in the input sequence. On failure, this
            value is undefined and may show the location of the start of the attempt, the location at
            which failure occured, null, or some other value.
            </summary>
        </member>
        <member name="T:ParserObjects.IResult`1">
            <summary>
            Result object from a Parse operation
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:ParserObjects.IResult`1.Value">
            <summary>
            The produced value from the successful parse. If Success is false, this value is undefined.
            </summary>
        </member>
        <member name="M:ParserObjects.IResult`1.Transform``1(System.Func{`0,``0})">
            <summary>
            Transforms the Value of the result to a new form
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseResultExtensions.WithError``1(ParserObjects.IResult{``0},System.String)">
            <summary>
            Create a copy of the result, with a new error message. If the original result is
            Success, the result is returned unmodified.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseResultExtensions.WithError``1(ParserObjects.IResult{``0},System.Func{System.String,System.String})">
            <summary>
            Create a copy of the result with a modified error message. If the original result is
            Success, the result is returned unmodified.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="mutateError"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseResultExtensions.Deconstruct``1(ParserObjects.IResult{``0},System.Boolean@,``0@)">
            <summary>
            Get the success flag and, if success is true, the result value
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="result"></param>
            <param name="success"></param>
            <param name="value"></param>
        </member>
        <member name="M:ParserObjects.ParseResultExtensions.Deconstruct``1(ParserObjects.IResult{``0},System.Boolean@,``0@,ParserObjects.Location@)">
            <summary>
            Get the success flag and location and, if success is true, the result value
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="result"></param>
            <param name="success"></param>
            <param name="value"></param>
            <param name="location"></param>
        </member>
        <member name="T:ParserObjects.ISequenceCheckpoint">
            <summary>
            A snapshot of a sequence at a specific point. Can be used to return the sequence to that
            point.
            </summary>
        </member>
        <member name="M:ParserObjects.ISequenceCheckpoint.Rewind">
            <summary>
            Return the sequence to the state it was when the checkpoint was taken.
            </summary>
        </member>
        <member name="T:ParserObjects.ISequence">
            <summary>
            An input stream with metadata
            </summary>
        </member>
        <member name="P:ParserObjects.ISequence.CurrentLocation">
            <summary>
            The approximate location from the source data where the current input item was located, if
            available.
            </summary>
        </member>
        <member name="P:ParserObjects.ISequence.IsAtEnd">
            <summary>
            True if the sequence is at the end and no more values may be retrieved. False if the sequence
            is exhausted and no more values are available.
            </summary>
        </member>
        <member name="M:ParserObjects.ISequence.Checkpoint">
            <summary>
            Take a snapshot of the state of the sequence, which can be returned to later if the
            sequence needs to be rewound.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.ISequence`1">
            <summary>
            An input sequence of items. Similar to IEnumerable/IEnumerator but with the ability to rewind and
            put back items which are not needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ParserObjects.ISequence`1.PutBack(`0)">
            <summary>
            Put back the given value to the head of the sequence. This value does not need to be a value
            which previously has been taken off the sequence.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ParserObjects.ISequence`1.GetNext">
            <summary>
            Get the next value from the sequence or a default value if the sequence is at the end, and
            increments the location
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ISequence`1.Peek">
            <summary>
            Gets the next value off the sequence but does not advance the location
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.SequenceExtensions.AsEnumerable``1(ParserObjects.ISequence{``0})">
            <summary>
            Convert the sequence to an IEnumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.SequenceExtensions.Select``2(ParserObjects.ISequence{``0},System.Func{``0,``1})">
            <summary>
            Transform a sequence of one type into a sequence of another type by applying a transformation
            function to every element.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="input"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.SequenceExtensions.Where``1(ParserObjects.ISequence{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filter elements in a sequence to only return items which match a predicate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.JavaScriptStyleParserMethods.NumberString">
            <summary>
            JavaScript-style number literal, returned as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.JavaScriptStyleParserMethods.Number">
            <summary>
            JavaScript-style number literal returned as a parsed Double
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.JavaScriptStyleParserMethods.StrippedString">
            <summary>
            Parse a JavaScript-style string, removing quotes and replacing escape sequences
            with their literal values
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.JavaScriptStyleParserMethods.String">
            <summary>
            Parse a JavaScript-style string, returning the complete string literal with quotes
            and escape sequences unmodified.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Location">
            <summary>
            An approximate description of the location in the data source where an item is located. Notice
            that some types of input may not make this information precisely knowable.
            </summary>
        </member>
        <member name="M:ParserObjects.Location.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            An approximate description of the location in the data source where an item is located. Notice
            that some types of input may not make this information precisely knowable.
            </summary>
        </member>
        <member name="T:ParserObjects.FailFunction`1">
            <summary>
            Create a failure result with the given error message
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="error"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.SuccessFunction`1">
            <summary>
            Create a success result with the given value
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.ParserFunction`2">
            <summary>
            Execute a parse callback, with success and failure factory methods to create the necessary
            results
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="t"></param>
            <param name="success"></param>
            <param name="fail"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.ParserMethods`1">
            <summary>
            Parser methods for building combinators using declarative syntax
            </summary>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.LeftApply``1(ParserObjects.IParser{`0,``0},ParserObjects.Parsers.LeftApply{`0,``0}.GetRightFunc,ParserObjects.Quantifier)">
            <summary>
            A left-associative parser where the left item is parsed unconditionally, and the result of the
            left parser is applied to the right parser. This new result is then treated as the 'left' value
            for the next iteration of the right parser. This can be used when many rules have a common prefix
            and you don't want to backtrack through the prefix on every attempt.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="left"></param>
            <param name="getRight"></param>
            <param name="quantifier"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.RightApply``2(ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``0},ParserObjects.Parsers.RightApply{`0,``0,``1}.Produce,ParserObjects.Parsers.RightApply{`0,``0,``1}.Create,ParserObjects.Quantifier)">
            <summary>
            a right-associative parser where the parser attempts to parse a sequence of items and middles
            recursively: self := &lt;item&gt; (&lt;middle&gt; &lt;self&gt;)*. 
            </summary>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="item"></param>
            <param name="middle"></param>
            <param name="produce"></param>
            <param name="getMissingRight"></param>
            <param name="quantifier"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Any">
            <summary>
            Matches anywhere in the sequence except at the end, and consumes 1 token of input
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Bool(ParserObjects.IParser{`0})">
            <summary>
            Parses a parser, returns true if the parser succeeds, false if it fails
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Chain``2(ParserObjects.IParser{`0,``0},System.Func{``0,ParserObjects.IParser{`0,``1}})">
            <summary>
            Executes a parser, and uses the value to determine the next parser to execute
            </summary>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getNext"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Choose``2(ParserObjects.IParser{`0,``0},System.Func{``0,ParserObjects.IParser{`0,``1}})">
            <summary>
            Executes a parser without consuming any input, and uses the value to determine the next
            parser to execute
            </summary>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getNext"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Combine(ParserObjects.IParser{`0}[])">
            <summary>
            Given a list of parsers, parse each in sequence and return a list of object
            results on success.
            </summary>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Deferred``1(System.Func{ParserObjects.IParser{`0,``0}})">
            <summary>
            Get a reference to a parser dynamically. Avoids circular dependencies in the grammar
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="getParser"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Empty">
            <summary>
            The empty parser, consumers no input and always returns success at any point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.End">
            <summary>
            Matches affirmatively at the end of the input, fails everywhere else.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Examine``1(ParserObjects.IParser{`0,``0},System.Action{ParserObjects.Parsers.Examine{`0,``0}.Context},System.Action{ParserObjects.Parsers.Examine{`0,``0}.Context})">
            <summary>
            Invoke callbacks before and after a parse
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="before"></param>
            <param name="after"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Examine(ParserObjects.IParser{`0},System.Action{ParserObjects.Parsers.Examine{`0}.Context},System.Action{ParserObjects.Parsers.Examine{`0}.Context})">
            <summary>
            Invoke callbacks before and after a parse
            </summary>
            <param name="parser"></param>
            <param name="before"></param>
            <param name="after"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Fail``1(System.String)">
            <summary>
            A parser which unconditionally returns failure.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.First``1(ParserObjects.IParser{`0,``0}[])">
            <summary>
            Return the result of the first parser which succeeds
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Function``1(ParserObjects.ParserFunction{`0,``0})">
            <summary>
            Invoke a function callback to perform the parse at the current location in the input
            stream
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Optional``1(ParserObjects.IParser{`0,``0},System.Func{``0})">
            <summary>
            Attempt to parse an item and return a default value otherwise
            </summary>
            <param name="p"></param>
            <param name="getDefault"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Optional``1(ParserObjects.IParser{`0,``0},System.Func{ParserObjects.ISequence{`0},``0})">
            <summary>
            Attempt to parse an item and return a default value otherwise
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="getDefault"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Predict``1(System.Action{ParserObjects.Parsers.Predict{`0,``0}.IConfiguration})">
            <summary>
            Given the next input lookahead value, select the appropriate parser to use to continue
            the parse
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="setup"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Produce``1(System.Func{``0})">
            <summary>
            Produce a value without consuming anything out of the input sequence
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Produce``1(System.Func{ParserObjects.ISequence{`0},``0})">
            <summary>
            Produce a value given the input sequence.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Produce``1(ParserObjects.Parsers.Produce{`0,``0}.Function)">
            <summary>
            Produces a value given the input sequence and the current contextual data
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Replaceable``1(ParserObjects.IParser{`0,``0})">
            <summary>
            Serves as a placeholder in the parser tree where an in-place replacement can be made.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="defaultParser"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Sequential``1(System.Func{ParserObjects.Parsers.Sequential.State{`0},``0})">
            <summary>
            Execute a specially-structured callback to turn a parse into sequential, procedural
            code.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Transform``2(ParserObjects.IParser{`0,``0},System.Func{``0,``1})">
            <summary>
            Transform one node into another node to fit into the grammar
            </summary>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <param name="parser"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.List``1(ParserObjects.IParser{`0,``0},System.Boolean)">
            <summary>
            Parse a list of items. 
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="atLeastOne">If true, the list must have at least one element or the parse fails. If
            false, an empty list returns success.</param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.List``1(ParserObjects.IParser{`0,``0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Parse a list of items with defined minimum and maximum quantities.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="minimum"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.SeparatedList``1(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0},System.Boolean)">
            <summary>
            Parse a list of items separated by a separator pattern.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="separator"></param>
            <param name="atLeastOne">True if the list must contain at least one element or failure. False
            if an empty list can be returned.</param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.SeparatedList``1(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Parse a list of items separated by a separator pattern, with minimum and
            maximum item counts
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="p"></param>
            <param name="separator"></param>
            <param name="minimum"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.And(ParserObjects.IParser{`0}[])">
            <summary>
            Tests several parsers sequentially. Returns success if they all succeed, otherwise
            returns failure. Consumes input but returns no explicit output.
            </summary>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.If``1(ParserObjects.IParser{`0},ParserObjects.IParser{`0,``0})">
            <summary>
            Tests the predicate parser. If the predicate succeeds, invoke the success parser
            Otherwise return Failure.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="predicate"></param>
            <param name="onSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.If``1(ParserObjects.IParser{`0},ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``0})">
            <summary>
            Tests the predicate parser. If the predicate succeeds, invoke the success parser.
            Otherwise invokes the failure parser.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="predicate"></param>
            <param name="onSuccess"></param>
            <param name="onFail"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Not(ParserObjects.IParser{`0})">
            <summary>
            Invoke the given parser and invert the result. On Success return Failure, on Failure return
            Success. Consumes input but returns no output.
            </summary>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Or(ParserObjects.IParser{`0}[])">
            <summary>
            Tests several parsers sequentially. Returns Success if any parser succeeds, returns
            Failure otherwise. Consumes input but returns no explicit output.
            </summary>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.NegativeLookahead(ParserObjects.IParser{`0})">
            <summary>
            Zero-length assertion that the given pattern does not match from the current position. No
            input is consumed
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.PositiveLookahead(ParserObjects.IParser{`0})">
            <summary>
            Zero-length assertion that the given pattern matches from the current position. No input is
            consumed.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Match(System.Func{`0,System.Boolean})">
            <summary>
            Test the next input value and return it, if it matches the predicate
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Match(`0)">
            <summary>
            Get the next input value and return it if it .Equals() to the given value
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Match(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Get the next few input values and compare them one-by-one against an ordered sequence of test
            values. If every value in the sequence matches, return the sequence as a list.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.MatchAny(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Optimized implementation of First() which returns an input which matches any of the given pattern
            strings. Uses a Trie internally to greedily match the longest matching input sequence
            </summary>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``3(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},System.Func{``0,``1,``2})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T2"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``4(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``5(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``6(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},ParserObjects.IParser{`0,``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="p5"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``7(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},ParserObjects.IParser{`0,``4},ParserObjects.IParser{`0,``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="p5"></param>
            <param name="p6"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``8(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},ParserObjects.IParser{`0,``4},ParserObjects.IParser{`0,``5},ParserObjects.IParser{`0,``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="p5"></param>
            <param name="p6"></param>
            <param name="p7"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``9(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},ParserObjects.IParser{`0,``4},ParserObjects.IParser{`0,``5},ParserObjects.IParser{`0,``6},ParserObjects.IParser{`0,``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
            <typeparam name="T8"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="p5"></param>
            <param name="p6"></param>
            <param name="p7"></param>
            <param name="p8"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Rule``10(ParserObjects.IParser{`0,``0},ParserObjects.IParser{`0,``1},ParserObjects.IParser{`0,``2},ParserObjects.IParser{`0,``3},ParserObjects.IParser{`0,``4},ParserObjects.IParser{`0,``5},ParserObjects.IParser{`0,``6},ParserObjects.IParser{`0,``7},ParserObjects.IParser{`0,``8},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>
            Parse a sequence of productions and reduce them into a single output. If any item fails, rollback
            all and return failure
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
            <typeparam name="T8"></typeparam>
            <typeparam name="T9"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="p5"></param>
            <param name="p6"></param>
            <param name="p7"></param>
            <param name="p8"></param>
            <param name="p9"></param>
            <param name="produce"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Trie``1(ParserObjects.IReadOnlyTrie{`0,``0})">
            <summary>
            Look up sequences of inputs in an ITrie to greedily find the longest matching sequence
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="readOnlyTrie"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods`1.Trie``1(System.Action{ParserObjects.IInsertableTrie{`0,``0}})">
            <summary>
            Lookup sequences of inputs in an ITrie to greedily find the longest matching sequence.
            Provides a trie instance and a callback to populate it with values
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="setupTrie"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.CamelCase">
            <summary>
            Parses a CamelCase identifier and returns the list of individual strings in
            the identifier. Parses lowerCamelCase and UpperCamelCase
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.LowerCamelCase">
            <summary>
            Parses a lowerCamelCase identifier. If the first character is a letter, it is 
            expected to be lower-case
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.UpperCamelCase">
            <summary>
            Parses an UpperCamelCase string. If the first character is a letter, it is expected to
            be upper-case. Also known as 'Pascal Case'
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.SpinalCase">
            <summary>
            Matches a spinal-case identifier, with words separated by dashes. Characters can be
            letters of any case or digits. This is also known as 'kebab-case' or 'lisp-case'
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.ScreamingSpinalCase">
            <summary>
            Matches a SCREAMING-SPINAL-CASE identifier, with all-upper-case words separated by
            dashes. Words may contain upper-case letters or digits.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.SnakeCase">
            <summary>
            Matches snake_case identifiers of letters (any case) or digits separated by
            underscores. Also known as pothole_case
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.ScreamingSnakeCase">
            <summary>
            Matches SCREAMING_SNAKE_CASE with upper-case letters and digits separated by
            underscores. Also known as MACRO_CASE or CONSTANT_CASE
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Letter">
            <summary>
            Matches a Letter character
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Word">
            <summary>
            Matches a series of consecutive letter characters
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.UpperCase">
            <summary>
            Matches an upper-case letter character
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.LowerCase">
            <summary>
            Matches a lower-case letter character
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Symbol">
            <summary>
            Matches a symbol or punctuation character.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.CharacterString(System.String)">
            <summary>
            Convenience method to match a literal sequence of characters and return the
            result as a string.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Digit">
            <summary>
            Parses a single digit 0-9
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.NonZeroDigit">
            <summary>
            Parses a single non-zero digit 1-9
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.DigitString">
            <summary>
            Parses digits in series and returns them as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.HexadecimalDigit">
            <summary>
            Returns a single hexadecimal digit: 0-9, a-f, A-F
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.HexadecimalString">
            <summary>
            Returns a sequence of at least one hexadecimal digits and returns them as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.PrefixedLine(System.String)">
            <summary>
            Parses a line of text, starting with a prefix and going until a newline or end
            of input. Newline not included.
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Line">
            <summary>
            Parses a line of text until a newline or end of input. Newline not included.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.DoubleQuotedString">
            <summary>
            Double-quoted string literal, with backslash-escaped quotes. The returned string is the string
            literal with quotes and escapes
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.SingleQuotedString">
            <summary>
            Single-quoted string literal, with backslash-escaped quotes. The returned string is the string
            literal with quotes and escapes
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.DelimitedStringWithEscapedDelimiters(System.Char,System.Char,System.Char)">
            <summary>
            A parser for delimited strings. Returns the string literal with open sequence, close sequence,
            and internal escape sequences
            </summary>
            <param name="openStr"></param>
            <param name="closeStr"></param>
            <param name="escapeStr"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.StrippedDoubleQuotedString">
            <summary>
            Double-quoted string with backslash-escaped quotes. The returned string is the string without
            quotes and without internal escape sequences
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.StrippedSingleQuotedString">
            <summary>
            Single-quoted string with backslash-escaped quotes. The returned string is the string without
            quotes and without internal escape sequences
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.StrippedDelimitedStringWithEscapedDelimiters(System.Char,System.Char,System.Char)">
            <summary>
            A parser for delimited strings. Returns the string literal, stripped of open sequence, close
            sequence, and internal escape sequences.
            </summary>
            <param name="openStr"></param>
            <param name="closeStr"></param>
            <param name="escapeStr"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Regex(System.String)">
            <summary>
            Creates a parser which attempts to match the given regular expression from the current
            position of the input stream
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.RegexPattern">
            <summary>
            Creates a parser which parses a regex pattern string into a Regex object for work with
            the RegexParser and RegexEngine
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.WhitespaceCharacter">
            <summary>
            Parses a single character of whitespace (' ', '\t', '\r', '\n','\v', etc)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.Whitespace">
            <summary>
            Parses a series of required whitespace characters and returns them as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParserMethods.OptionalWhitespace">
            <summary>
            Parses an optional series of whitespace characters and returns them as a string
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Parsers.AndParser`1">
            <summary>
            Tests several parsers sequentially. If all of them succeed return Success. If any Fail, 
            return Failure. Consumes input but returns no explicit output.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.AnyParser`1">
            <summary>
            Matches any input item that isn't the end of input. Consumes exactly one input item and
            returns it.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.ChainParser`3">
            <summary>
            Executes the given parser and uses the value returned to select the next parser to execute
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.ChooseParser`3">
            <summary>
            Attempt to match a parser without consuming any input, and use the output value to choose
            the next parser to execute.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Create`2">
            <summary>
            Create a new parser instance on invocation, using information available from the current
            parse state.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Create`2.Parser">
            <summary>
            Create a parser dynamically using information from the parse state. The parser created is 
            not expected to be constant and will not be cached.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.DeferredParser`2">
            <summary>
            Looks up a parser at parse time, to avoid circular references in the grammar. The parser
            looked up is expected to be constant for the duration of the parse and may be cached.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.EmptyParser`1">
            <summary>
            The empty parser, consumes no input and always returns success
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.EndParser`1">
            <summary>
            Matches at the end of the input sequence. Fails if the input sequence is at any point 
            besides the end.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`2">
            <summary>
            Inserts a callback before and after the specified parser. Useful for debugging purposes
            and to adjust the input/output of a parser. Contains parsers and related machinery
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`2.Parser">
            <summary>
            Examine parser for parsers which return typed output. Executes callbacks before and
            after the parse.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`2.Context">
            <summary>
            Context information available during an examination. 
            </summary>
        </member>
        <member name="M:ParserObjects.Parsers.Examine`2.Context.#ctor(ParserObjects.IParser{`0,`1},ParserObjects.ParseState{`0},ParserObjects.IResult{`1})">
            <summary>
            Context information available during an examination. 
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`1">
            <summary>
            Inserts a callback before and after parser execution. Used for parsers with untyped output
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`1.Parser">
            <summary>
            The examine parser. Executes callbacks before and after the parser. Does not return
            typed output
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Examine`1.Context">
            <summary>
            The context object which holds information able to be examined.
            </summary>
        </member>
        <member name="M:ParserObjects.Parsers.Examine`1.Context.#ctor(ParserObjects.IParser{`0},ParserObjects.ParseState{`0},ParserObjects.IResult)">
            <summary>
            The context object which holds information able to be examined.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.FailParser`2">
            <summary>
            Returns unconditional failure, optionally with a helpful error message
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.FirstParser`2">
            <summary>
            Takes a list of parsers and attempts each one in order. Returns as soon as the first parser
            succeeds
            </summary>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.FuncParser`2">
            <summary>
            Invokes a delegate to perform the parse. The delegate may perform any logic necessary and
            imposes no particular structure.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.IfParser`2">
            <summary>
            Attempts to match a predicate condition and, invokes a specified parser on success or
            failure
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.LeftApply`2">
            <summary>
            Parser to help with left-associative or left-recursive parse situations. Executes an
            initial parser, and then passes that value to the right-hand-side production. The right
            value is then used as the new left value and the loop repeats. Contains the parser and
            related machinery
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.LeftApply`2.Parser">
            <summary>
            The left-apply parser, which handles left-associative parses without recursion. 
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.LimitedListParser`2">
            <summary>
            Executes an inner parser repeatedly, until it fails. All values are returned as a list.
            Expects a number of matches between minimum and maximum values, inclusive.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.MatchPatternParser`1">
            <summary>
            Given a literal sequence of values, pull values off the input sequence to match. If the 
            entire series matches, return it
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.MatchPredicateParser`1">
            <summary>
            Returns the next input item if it satisfies a predicate, failure otherwise.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.NegativeLookaheadParser`1">
            <summary>
            Negative lookahead parser. Tests the input to see if the inner parser matches. Return 
            success if the parser does not match, fail otherwise. Consumes no input.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.NotParser`1">
            <summary>
            Invokes a parser and inverses the result success status. If the parser succeeds, return 
            Failure. Otherwise returns Success. Consumes no input in either case and returns no output.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.OrParser`1">
            <summary>
            Tests several parsers sequentially, returning Success if any parser succeeds, Failure
            otherwise. Consumes input but returns no explicit output.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.PositiveLookaheadParser`1">
            <summary>
            Does a lookahead to see if there is a match. Returns a success or failure result, but does 
            not consume any actual input.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Pratt`3">
            <summary>
            Expression-oriented implementation of the Pratt parsing algorithm. Contains the parser,
            configuration and related machinery
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOperator"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="M:ParserObjects.Parsers.Pratt`3.CreateConfiguration">
            <summary>
            Create a new Configuration
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Parsers.Pratt`3.IConfiguration">
            <summary>
            Configuration for the parser. Allows adding and configuring new operators
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Pratt`3.Parser">
            <summary>
            Pratt parser implementation. Uses configuration values to control the parse.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Predict`2">
            <summary>
            Parser and related machinery to use a lookahead value to control the parse
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="M:ParserObjects.Parsers.Predict`2.CreateConfiguration">
            <summary>
            Create a new Configuration object
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Parsers.Predict`2.IConfiguration">
            <summary>
            Configuration for a predict parser. Allows setting a list of predicates and the parser
            to invoke when the predicate succeeds
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Predict`2.Parser">
            <summary>
            Parser to use the next lookahead item to determine which parser to invoke next. Does
            not consume the lookahead value.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Produce`2">
            <summary>
            Parser and related machinery to create a constant value during a parse
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Produce`2.Parser">
            <summary>
            Produces an output value unconditionally. Consumes no input. The callback has access to
            both the input sequence and the current contextual data, to help crafting the value.
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.RegexParser">
            <summary>
            Uses limited Regular Expression syntax to match a pattern of characters. 
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.ReplaceableParser`2">
            <summary>
            Delegates to an internal parser, and allows the internal parser to be replaced in-place 
            after the parser graph has been created. Useful for cases where grammar extensions or
            modifications need to be made after the parser has been created.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.RightApply`3">
            <summary>
            Parser and related machinery for handling a right-associative parse
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.RightApply`3.Parser">
            <summary>
            Attempts to parse a right-recursive or right-associative parse rule. Useful for limited
            situations, especially for parsing expressions
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.RuleParser`2">
            <summary>
            Parses a list of steps in sequence and produces a single output as a combination of outputs 
            of each step. Succeeds or fails as an atomic unit.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Sequential">
            <summary>
            Sequential parser and related classes
            </summary>
        </member>
        <member name="T:ParserObjects.Parsers.Sequential.State`1">
            <summary>
            State object for a sequential parse. Handles control flow and input sequence 
            management.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.Sequential.Parser`2">
            <summary>
            Parser for sequential callbacks. Executes a specially-structured callback with a state
            object so the user can control the flow of data between parsers and set breakpoints
            during debugging.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.TransformParser`3">
            <summary>
            Transforms the output of one parser into a different value. Only used to transform success
            values.
            </summary>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TMiddle"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.TransformResult`3">
            <summary>
            Transforms the raw result object, including the result type, result value, success flag or 
            error message.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput1"></typeparam>
            <typeparam name="TOutput2"></typeparam>
        </member>
        <member name="T:ParserObjects.Parsers.TrieParser`2">
            <summary>
            Uses an ITrie to match the longest pattern.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.ParseState`1">
            <summary>
            Contains state data and metadata about the progress of the parse. Provides references to
            useful objects which may affect the parse.
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="P:ParserObjects.ParseState`1.Input">
            <summary>
            The input sequence being used by the parser
            </summary>
        </member>
        <member name="P:ParserObjects.ParseState`1.Data">
            <summary>
            The current contextual state data used by the parser
            </summary>
        </member>
        <member name="M:ParserObjects.ParseState`1.Log(ParserObjects.IParser,System.String)">
            <summary>
            If a log callback is provided, pass a log message to the callback
            </summary>
            <param name="parser"></param>
            <param name="message"></param>
        </member>
        <member name="M:ParserObjects.ParseState`1.Fail``1(ParserObjects.IParser{`0,``0},System.String,ParserObjects.Location)">
            <summary>
            Create a Failure result for the given parser with the given error information
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="error"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseState`1.Fail(ParserObjects.IParser{`0},System.String,ParserObjects.Location)">
            <summary>
            Create a failure result for the given parser with the given error information
            </summary>
            <param name="parser"></param>
            <param name="error"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseState`1.Success``1(ParserObjects.IParser{`0,``0},``0,ParserObjects.Location)">
            <summary>
            Create a success result for the given parser with the given result value
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="parser"></param>
            <param name="output"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.ParseState`1.Success(ParserObjects.IParser{`0},System.Object,ParserObjects.Location)">
            <summary>
            Create a success result for the given parser with the given result value, if any
            </summary>
            <param name="parser"></param>
            <param name="output"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Quantifier">
            <summary>
            Flag to tell how many items a parser should match, if the parser is capable of matching
            more than one item. Not all parsers with repetition will support all Quantifiers.
            </summary>
        </member>
        <member name="F:ParserObjects.Quantifier.ExactlyOne">
            <summary>
            The parser should match exactly one item. The parser will return an error if there are
            no matching items, and will ignore additional matches
            </summary>
        </member>
        <member name="F:ParserObjects.Quantifier.ZeroOrOne">
            <summary>
            The parser should match one optional item. The parser will return success whether it
            matches an item or not, and will ignore any potential matches after the first one.
            </summary>
        </member>
        <member name="F:ParserObjects.Quantifier.ZeroOrMore">
            <summary>
            The parser should match any number of items. The parser will return success if there
            are no matches. If there are matches, the parser will attempt to match as many as
            there are.
            </summary>
        </member>
        <member name="F:ParserObjects.Quantifier.Range">
            <summary>
            The parser expects to match a number of items in a given range. The bounds of the range
            are passed separately
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.Regex">
            <summary>
            Represents a compiled regex pattern. Used by the RegexEngine to perform a match.
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.RegexEngine">
            <summary>
            Engine to execute regex pattern matching given a Regex and an input sequence
            </summary>
        </member>
        <member name="M:ParserObjects.Regexes.RegexEngine.GetMatch(ParserObjects.ISequence{System.Char},ParserObjects.Regexes.Regex)">
            <summary>
            Attempts to match the given regex pattern on the given input starting at it's current
            location.
            </summary>
            <param name="input"></param>
            <param name="regex"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Regexes.RegexException">
            <summary>
            Exception thrown during Regex pattern parsing and regex engine execution
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.IRegexNode">
            <summary>
            An abstract syntax node for a regex pattern. Represents a single construct in the regex
            pattern. Used to create a list of RegexState objects for performing the actual match. 
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.RegexNodes">
            <summary>
            Abstract factory class to create regex nodes. Used by the parser to create nodes according
            to the current construct in the pattern.
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.RegexState">
            <summary>
            Represents a state at a point in evaluating a regular expression. At each point, the
            regex will attempt to match the current state against the current input
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Type">
            <summary>
            The type of state
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.CanBacktrack">
            <summary>
            Whether or not this state supports backtracking.
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Quantifier">
            <summary>
            The quantifier that controls how many times this state should match.
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.ValuePredicate">
            <summary>
            A predicate that determines whether a value matches
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Group">
            <summary>
            All substates if this state is a group
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Alternations">
            <summary>
            All possibilities in an alternation
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Description">
            <summary>
            A brief description of the state, to help with tracing/debugging
            </summary>
        </member>
        <member name="P:ParserObjects.Regexes.RegexState.Maximum">
            <summary>
            The maximum number of times this state can match, if it supports more than one. Used
            with Range quantifiers
            </summary>
        </member>
        <member name="T:ParserObjects.Regexes.RegexStateType">
            <summary>
            Type of the regex state. Used internally by the engine to dispatch matching logic
            </summary>
        </member>
        <member name="F:ParserObjects.Regexes.RegexStateType.EndOfInput">
            <summary>
            The end state
            </summary>
        </member>
        <member name="F:ParserObjects.Regexes.RegexStateType.Group">
            <summary>
            The state is a nested, parenthesized grouping of one or more substates
            </summary>
        </member>
        <member name="F:ParserObjects.Regexes.RegexStateType.MatchValue">
            <summary>
            The state requires matching a value
            </summary>
        </member>
        <member name="F:ParserObjects.Regexes.RegexStateType.Alternation">
            <summary>
            The state is an alternation of substates
            </summary>
        </member>
        <member name="T:ParserObjects.Result`1">
            <summary>
            Parser result object which holds the result value and helpful metadata
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:ParserObjects.Result`1.#ctor(ParserObjects.IParser,System.Boolean,`0,ParserObjects.Location,System.String)">
            <summary>
            Parser result object which holds the result value and helpful metadata
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:ParserObjects.Sequences.EnumerableExtensions.ToSequence``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Wrap the enumerable as a sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="endValue">An end value to return when the sequence is exhausted</param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Sequences.EnumerableExtensions.ToSequence``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Wrap the enumerable as a sequence
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="getEndValue">Get a value to return when the sequence is exhausted</param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Sequences.EnumerableSequence`1">
            <summary>
            Wraps an IEnumerable as an ISequence. Makes the items from the enumerable usable in parse 
            operations
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Sequences.FilterSequence`1">
            <summary>
            Filter a sequence to only return items which match a predicate
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Sequences.MapSequence`2">
            <summary>
            A sequence decorator which takes items from the input sequence and transforms them. Notice
            that when using MapSequence, you should not directly access the underlying sequence
            anymore. Data may be lost, because items put back to the MapSequence cannot be un-mapped
            and put back to the underlying sequence.
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Sequences.ParseResultSequence`2">
            <summary>
            An adaptor to change output values from an IParser into an ISequence of results
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="T:ParserObjects.Sequences.SequenceBuffer">
            <summary>
            Adaptor to represent a sequence as an indexable buffer like an array or list
            </summary>
        </member>
        <member name="T:ParserObjects.Sequences.SequenceEnumerable`1">
            <summary>
            Adaptor to convert ISequence to IEnumerable. The enumerable should only be enumerated once
            because the stream will not automatically rewind to an earlier position.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Sequences.StreamByteSequence">
            <summary>
            A sequence of bytes pulled from a Stream or StreamReader
            </summary>
        </member>
        <member name="T:ParserObjects.Sequences.StreamCharacterSequence">
            <summary>
            A sequence of characters read from a Stream, such as from a file
            </summary>
        </member>
        <member name="M:ParserObjects.Sequences.StreamExtensions.ToByteSequence(System.IO.Stream,System.String)">
            <summary>
            Converts an existing  Stream to an ISequence of byte. Calling .Dispose() on the sequence
            will dispose the stream as well.
            </summary>
            <param name="stream"></param>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Sequences.StreamExtensions.ToCharSequence(System.IO.Stream,System.Text.Encoding,System.String)">
            <summary>
            Converts an existing Stream to a sequence of char using the provided encoding (UTF-8 by
            default). Calling .Dispose() on the sequence will dispose the stream as well.
            </summary>
            <param name="stream"></param>
            <param name="encoding"></param>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Sequences.StreamExtensions.ToCharSequence(System.IO.StreamReader,System.String)">
            <summary>
            Converts an existing StreamReader to a sequence of char. Calling .Dispose() on the
            sequence will dispose the reader as well.
            </summary>
            <param name="streamReader"></param>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Sequences.StringCharacterSequence">
            <summary>
            A sequence of characters read from a string
            </summary>
        </member>
        <member name="M:ParserObjects.Sequences.StringExtensions.ToCharacterSequence(System.String)">
            <summary>
            Wrap the string as a sequence of characters
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.SqlStyleParserMethods.Comment">
            <summary>
            SQL-style comment which starts with '--' and includes all characters until the end
            of line
            </summary>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Utility.AlwaysFullRingBuffer`1">
            <summary>
            Simplified ring-buffer ('circular buffer') implementation which makes several assumptions 
            for simplicity and performance. The buffer is always considered full (reading more data
            than has been written will return default values) and values are not modifiable. This class
            is not concurrency-safe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ParserObjects.Utility.Assert">
            <summary>
            Helper methods for enforcing invariants
            </summary>
        </member>
        <member name="T:ParserObjects.Utility.InsertOnlyTrie`2">
            <summary>
            Trie implementation which allows inserts of values but not updates of values. Once a value is
            inserted into the trie, it cannot be removed or modified
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="T:ParserObjects.Utility.ParserDefaultStringifier">
            <summary>
            Default logic for implementing IParser.ToString()
            </summary>
        </member>
        <member name="M:ParserObjects.Utility.ParserDefaultStringifier.ToString(ParserObjects.IParser)">
            <summary>
            Attempts to create a string representation of a string which is both sufficiently
            helpful but not overly verbose. Use the .Name if provided.
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="T:ParserObjects.Utility.SingleReplaceResult">
            <summary>
            Result of a single replacement operation
            </summary>
        </member>
        <member name="M:ParserObjects.Utility.SingleReplaceResult.#ctor(ParserObjects.IReplaceableParserUntyped,ParserObjects.IParser,ParserObjects.IParser)">
            <summary>
            Result of a single replacement operation
            </summary>
        </member>
        <member name="P:ParserObjects.Utility.SingleReplaceResult.Success">
            <summary>
            True if the replace happened, false if it did not
            </summary>
        </member>
        <member name="M:ParserObjects.Utility.SingleReplaceResult.Deconstruct(System.Boolean@,ParserObjects.IParser@,ParserObjects.IParser@)">
            <summary>
            Get the previous and current parser value
            </summary>
            <param name="success"></param>
            <param name="previous"></param>
            <param name="current"></param>
        </member>
        <member name="M:ParserObjects.Utility.SingleReplaceResult.Deconstruct(System.Boolean@,ParserObjects.IParser@,ParserObjects.IParser@,ParserObjects.IReplaceableParserUntyped@)">
            <summary>
            Get the previous parser, current parser, and the ReplaceableParser parent
            </summary>
            <param name="success"></param>
            <param name="previous"></param>
            <param name="current"></param>
            <param name="replaceable"></param>
        </member>
        <member name="T:ParserObjects.Utility.MultiReplaceResult">
            <summary>
            Contains the results of multiple replaces from the parser graph
            </summary>
        </member>
        <member name="P:ParserObjects.Utility.MultiReplaceResult.Results">
            <summary>
            The individual replace results
            </summary>
        </member>
        <member name="P:ParserObjects.Utility.MultiReplaceResult.Success">
            <summary>
            True if all replacements succeeded, false if no attempts were made or if any result
            failed
            </summary>
        </member>
        <member name="T:ParserObjects.Visitors.BnfStringifyVisitor">
            <summary>
            Parser-visitor to traverse the parser-graph and attempt to produce a string of approximate
            pseudo-BNF to describe the grammar. Proper execution of this visitor depends on parsers having
            the .Name value set. If you have custom parser types you can create a subclass of this visitor
            type with signature 'public VisitChild(MyParserType parser, State state)' and it should dispatch to
            them as required.
            </summary>
        </member>
        <member name="T:ParserObjects.Visitors.FindParserVisitor">
            <summary>
            Parser-visitor type to traverse the parser tree and find matching parser nodes.
            </summary>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.Named(System.String,ParserObjects.IParser)">
            <summary>
            Search for a parser with the given Name. Returns only the first result in case of duplicates
            </summary>
            <param name="name"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.OfType``1(ParserObjects.IParser)">
            <summary>
            Search for all parsers of the given type. Returns all results.
            </summary>
            <typeparam name="TParser"></typeparam>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.Replace(ParserObjects.IParser,System.Func{ParserObjects.IReplaceableParserUntyped,System.Boolean},ParserObjects.IParser)">
            <summary>
            Search for ReplaceableParsers matching a predicate and attempt to replace their contents with the
            replacement parser if it is found. The replacement parser must be non-null and of the correct
            type. Replaces all matching instances.
            </summary>
            <param name="root"></param>
            <param name="predicate"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.Replace(ParserObjects.IParser,System.String,ParserObjects.IParser)">
            <summary>
            Search for ReplaceableParsers with the given name and attempt to replace their contents with the
            replacement parser. The replacement parser must be non-null and of the correct type. Replaces
            all matching instances.
            </summary>
            <param name="root"></param>
            <param name="name"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.Replace``2(ParserObjects.IParser,System.Func{ParserObjects.IReplaceableParserUntyped,System.Boolean},System.Func{ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0,``1}})">
            <summary>
            Search for ReplaceableParsers matching a predicate and attempt to transform the contents using
            the given transformation. The contents of the ReplaceableParser will be replaced with the
            transformed result if it is new and valid.
            </summary>
            <param name="root"></param>
            <param name="predicate"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ParserObjects.Visitors.FindParserVisitor.Replace``2(ParserObjects.IParser,System.String,System.Func{ParserObjects.IParser{``0,``1},ParserObjects.IParser{``0,``1}})">
            <summary>
            Search for ReplaceableParsers with the given name and attempt to transform the contents using
            the given transformation. The contents of the ReplaceableParser will be replaced with the
            transformed result if it is new and valid.
            </summary>
            <param name="root"></param>
            <param name="name"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
    </members>
</doc>
